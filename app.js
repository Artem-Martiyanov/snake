const startButton = document.getElementById("btn-start-game")const mainScreen = document.querySelector(".main-screen")const prevScore = document.querySelector(".prev-score")const getRandom = (max) => Math.floor(Math.random() * max)const gameSettings = {    field: {        width: 400,        height: 400    },    speed: 100,    cell: {        size: 20,        color: "#333333"    },    borderMode: 1}startButton.addEventListener("click", () => {    gameInit()})class Game {    constructor({field, speed, cell, borderMode}, keyHandler) {        window.addEventListener("keydown", keyHandler)        const mobileControlButtons = document.querySelectorAll(".mobile-control-buttons__item")        mobileControlButtons.forEach((button) => {            button.addEventListener("click", keyHandler)        })        const gameField = document.getElementById("canvas")        const context = gameField.getContext("2d")        if (borderMode) gameField.style.border = '5px solid teal'        this.scoreTable = document.querySelector(".score")        gameField.width = field.width        gameField.height = field.height        this.controlButtons = mobileControlButtons;        this.keyHandler = keyHandler        this.gameField = gameField        this.ctx = context        this.field = field        this.cell = cell        this.scoreCounter = 0        this.scoreTable.innerText = this.scoreCounter        this.isEnd = false        this.borderMode = borderMode    }    upScore() {        this.scoreCounter++        this.scoreTable.innerText = this.scoreCounter    }    clear() {        this.gameField.width = this.field.width    }    render(data, cellSize, cellColor) {        if (Array.isArray(data)) {            for (const pos of data) {                this.ctx.beginPath()                this.ctx.rect(pos.x, pos.y, cellSize, cellSize)                this.ctx.fillStyle = cellColor                this.ctx.fill()            }        } else {            this.ctx.beginPath()            this.ctx.rect(data.x, data.y, cellSize, cellSize)            this.ctx.fillStyle = cellColor            this.ctx.fill()        }    }    end(loop) {        clearInterval(loop)        window.removeEventListener("keydown", this.keyHandler)        this.controlButtons.forEach((button) => {            button.removeEventListener("click", this.keyHandler)        })        this.isEnd = true        prevScore.innerText = this.scoreCounter        mainScreen.classList.remove("disabled")    }}class Snake {    constructor({size = 10, color}, field) {        this.cellSize = size        this.cellColor = color        this.field = field        this.body = [{x: this.field.width / 2, y: this.field.height / 2}, 0, 0]    }    dX = 0    dY = 0    keyHandler = (e) => {        let direction = e.key ? e.key : e.currentTarget.id        switch (direction) {            case "ArrowUp": {                if (this.dY === 0 && this.body[0].y - this.cellSize !== this.body[1].y) {                    this.dY = -1                    this.dX = 0                }                break            }            case "ArrowDown": {                if (this.dY === 0 && this.body[0].y + this.cellSize !== this.body[1].y) {                    this.dY = 1                    this.dX = 0                }                break            }            case "ArrowRight": {                if (this.dX === 0 && this.body[0].x + this.cellSize !== this.body[1].x) {                    this.dY = 0                    this.dX = 1                }            }                break            case "ArrowLeft": {                if (this.dX === 0 && this.body[0].x - this.cellSize !== this.body[1].x) {                    this.dY = 0                    this.dX = -1                }                break            }        }    }    move() {        if (this.dX || this.dY) {            if (this.body.length > 1) {                for (let i = this.body.length - 1; i > 0; i--) {                    this.body[i] = {...this.body[i - 1]}                }            }            this.body[0].x += this.dX * this.cellSize            this.body[0].y += this.dY * this.cellSize        }    }    isBorder(borderMode) {        let flag = this.body[0].x === this.field.width || this.body[0].x < 0 ||            this.body[0].y === this.field.height || this.body[0].y < 0        if (borderMode) {            return flag        } else {            // Правая граница            if (this.body[0].x > this.field.width) {                this.body[0].x = 0            }            // Нижняя граница            if (this.body[0].y > this.field.height) {                this.body[0].y = 0            }            // Левая граница            if (this.body[0].x < 0) {                this.body[0].x = this.field.width - this.cellSize            }            // Верхняя граница            if (this.body[0].y < 0) {                this.body[0].y = this.field.height - this.cellSize            }        }    }    isSelfAttack() {        let result = false        this.body.forEach((element, i, body) => {            if (body[0].x === element.x && body[0].y === element.y && i !== 0) {                result = true            }        })        return result    }    isFruit(fruitPos) {        return fruitPos.x === this.body[0].x && fruitPos.y === this.body[0].y    }    grow() {        this.body.length++    }}class Fruit {    constructor(color, size, field) {        this.color = color        this.size = size        this.field = field        this.position = {            x: getRandom(this.field.width / this.size) * this.size,            y: getRandom(this.field.height / this.size) * this.size        }    }    setPos(snakeBody) {        const isNumInSnake = ({x, y}) => {            let flag = false            snakeBody.forEach((el) => {                if (el.x === x && el.y === y) {                    flag = true                }            })            return flag        }        do {            this.position.x = getRandom(this.field.width / this.size) * this.size            this.position.y = getRandom(this.field.height / this.size) * this.size        } while (isNumInSnake(this.position))    }}/*=====================================================================*/function gameInit() {    const snake = new Snake(gameSettings.cell, gameSettings.field)    const game = new Game(gameSettings, snake.keyHandler)    const fruit = new Fruit("red", game.cell.size, game.field)    mainScreen.classList.add("disabled")    const gameLoop = setInterval(() => {        if (!game.isEnd) {            game.clear()            if (snake.isFruit(fruit.position)) {                game.upScore()                fruit.setPos(snake.body)                snake.grow()            }            snake.move()            if (snake.isBorder(game.borderMode) || snake.isSelfAttack()) {                game.end(gameLoop)            }            game.render(fruit.position, fruit.size, fruit.color)            game.render(snake.body, snake.cellSize, snake.cellColor)        }    }, gameSettings.speed)}