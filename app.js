const startButton = document.getElementById('btn-start-game')const mainScreen = document.querySelector('.main-screen')const prevScore = document.querySelector('.prev-score')const getRandom = (max) => Math.floor(Math.random() * max)const gameSettings = {    field: {        width: 400,        height: 400,    },    speed: 100,    cell: {        size: 20,        color: '#333333'    }}startButton.addEventListener('click', () => {    mainScreen.classList.add('disabled')    gameInit()})class Game {    constructor({field, speed, cell}, mouseHandler) {        window.addEventListener('keydown', mouseHandler)        const gameField = document.getElementById('canvas')        const context = gameField.getContext('2d')        this.scoreTable = document.querySelector('.score')        gameField.width = field.width        gameField.height = field.height        this.mouseHandler = mouseHandler        this.gameField = gameField        this.ctx = context        this.speed = speed        this.field = field        this.cell = cell        this.scoreCounter = 0        this.scoreTable.innerText = this.scoreCounter        this.isEnd = false    }    upScore() {        this.scoreCounter++        this.scoreTable.innerText = this.scoreCounter    }    clear() {        this.gameField.width = this.field.width    }    render(data, cellSize, cellColor) {        if (Array.isArray(data)) {            for (const pos of data) {                this.ctx.beginPath()                this.ctx.rect(pos.x, pos.y, cellSize, cellSize)                this.ctx.fillStyle = cellColor                this.ctx.fill()            }        } else {            this.ctx.beginPath()            this.ctx.rect(data.x, data.y, cellSize, cellSize)            this.ctx.fillStyle = cellColor            this.ctx.fill()        }    }    end() {        window.removeEventListener('keydown', this.mouseHandler)        this.isEnd = true        prevScore.innerText = this.scoreCounter    }}class Snake {    constructor({size = 10, color}, field) {        this.cellSize = size        this.cellColor = color        this.field = field        this.body = [{x: this.field.width / 2, y: this.field.height / 2}]    }    dX = 0    dY = 0    mouseHandler = (e) => {        switch (e.key) {            case 'ArrowUp': {                if (this.dY !== -1 && this.dY !== 1) {                    this.dY = -1                    this.dX = 0                }                break            }            case 'ArrowDown': {                if (this.dY !== 1 && this.dY !== -1) {                    this.dY = 1                    this.dX = 0                }                break            }            case 'ArrowRight': {                if (this.dX !== 1 && this.dX !== -1) {                    this.dY = 0                    this.dX = 1                }            }                break            case 'ArrowLeft': {                if (this.dX !== -1 && this.dX !== 1) {                    this.dY = 0                    this.dX = -1                }                break            }        }    }    move() {        if (this.dX || this.dY) {            if (this.body.length > 1) {                for (let i = this.body.length - 1; i > 0; i--) {                    this.body[i] = {...this.body[i - 1]};                }            }            this.body[0].x += this.dX * this.cellSize            this.body[0].y += this.dY * this.cellSize        }    }    isBorder() {        if (this.body[0].x >= this.field.width) {            this.body[0].x = 0        }        if (this.body[0].y >= this.field.height) {            this.body[0].y = 0        }        if (this.body[0].x < 0) {            this.body[0].x = this.field.width - this.cellSize        }        if (this.body[0].y < 0) {            this.body[0].y = this.field.height - this.cellSize        }    }    isSelfAttack() {        let result = false        this.body.forEach((element, i, body) => {            if (body[0].x === element.x && body[0].y === element.y && i !== 0) {                result = true;            }        })        return result    }    isFruit(fruitPos) {        return (fruitPos.x === this.body[0].x && fruitPos.y === this.body[0].y)    }    grow() {        this.body.length++    }}class Fruit {    constructor(color, size, field) {        this.color = color        this.size = size        this.field = field        this.position = {            x: getRandom(this.field.width / this.size) * this.size,            y: getRandom(this.field.height / this.size) * this.size        }    }    setPos(snakeBody) {        const isNumInSnake = ({x, y}) => {            let flag = false            snakeBody.forEach((el) => {                if (el.x === x && el.y === y) {                    flag = true                }            })            return flag        }        do {            this.position.x = getRandom(this.field.width / this.size) * this.size            this.position.y = getRandom(this.field.height / this.size) * this.size        } while (isNumInSnake(this.position))    }}/*=====================================================================*/function gameInit() {    const snake = new Snake(gameSettings.cell, gameSettings.field)    const game = new Game(gameSettings, snake.mouseHandler)    const fruit = new Fruit('red', game.cell.size, game.field)    setInterval(() => {        if (!game.isEnd) {            game.clear()            if (snake.isFruit(fruit.position)) {                game.upScore()                fruit.setPos(snake.body)                snake.grow()            }            snake.move()            if (snake.isSelfAttack()) {                game.end()                mainScreen.classList.remove('disabled')            }            snake.isBorder()            game.render(snake.body, snake.cellSize, snake.cellColor)            game.render(fruit.position, fruit.size, fruit.color)        }    }, game.speed)}