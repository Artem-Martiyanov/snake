const settingControls = document.querySelectorAll('.popup__control-range')const mainScreen = document.querySelector('.main-screen')const prevScore = document.querySelector('.prev-score')const startButton = document.getElementById('btn-start-game')const settingsButton = document.getElementById('btn-settings')const popupOverlay = document.querySelector('.popup')const getRandom = (max) => Math.floor(Math.random() * max)const gameSettings = {    field: {        width: 400,        height: 400    },    speed: 100,    cell: {        size: 20,        color: '#333333',        headColor: '#000000',        fruitColor: '#ff0000'    },    borderMode: 0,}function inputHandler(e) {    const thumb = e.currentTarget || e    const inputNumber = thumb.parentNode.nextElementSibling    const fillLine = thumb.parentNode.querySelector('.range-slider__fill-line')    inputNumber.value = thumb.value    fillLine.style.width =        (thumb.value - thumb.min) * (100 / (thumb.max - thumb.min)) + '%'    if (inputNumber.id === 'field-width') {        gameSettings.field.width = inputNumber.value    }    if (inputNumber.id === 'field-height') {        gameSettings.field.height = inputNumber.value    }}class Game {    constructor({field, cell, borderMode}, keyHandler) {        window.addEventListener('keydown', keyHandler)        const mobileControlButtons = document.querySelectorAll(            '.mobile-control-buttons__item'        )        mobileControlButtons.forEach((button) => {            button.addEventListener('click', keyHandler)        })        const canvas = document.getElementById('canvas')        canvas.width = field.width        canvas.height = field.height        field.width >= field.height ? canvas.style.width = '100%' : canvas.style.height = '100%'        const context = canvas.getContext('2d')        borderMode ? canvas.classList.add('border-mode') : canvas.classList.remove('border-mode')        this.scoreTable = document.querySelector('.score')        this.controlButtons = mobileControlButtons        this.keyHandler = keyHandler        this.canvas = canvas        this.ctx = context        this.field = field        this.cell = cell        this.scoreCounter = 0        this.scoreTable.innerText = this.scoreCounter        this.isEnd = false        this.borderMode = borderMode    }    upScore() {        this.scoreCounter++        this.scoreTable.innerText = this.scoreCounter    }    clear() {        this.canvas.width = this.field.width    }    render(data, cellSize, cellColor, headCellColor = cellColor) {        if (Array.isArray(data)) {            data.forEach((pos, i) => {                this.ctx.beginPath()                this.ctx.rect(pos.x, pos.y, cellSize, cellSize)                this.ctx.fillStyle = i ? cellColor : headCellColor                this.ctx.fill()            })        } else {            this.ctx.beginPath()            this.ctx.rect(data.x, data.y, cellSize, cellSize)            this.ctx.fillStyle = cellColor            this.ctx.fill()        }    }    end(loop) {        clearInterval(loop)        window.removeEventListener('keydown', this.keyHandler)        this.controlButtons.forEach((button) => {            button.removeEventListener('click', this.keyHandler)        })        this.isEnd = true        prevScore.innerText = this.scoreCounter        mainScreen.classList.remove('disabled')    }}class Snake {    constructor({size = 10, color, headColor}, field) {        this.cellSize = size        this.cellColor = color        this.headCellColor = headColor        this.field = field        this.body = [{x: this.field.width / 2, y: this.field.height / 2}, 0, 0]    }    dX = 0    dY = 0    keyHandler = (e) => {        let direction = e.key ? e.key : e.currentTarget.id        switch (direction) {            case 'ArrowUp': {                if (                    this.dY === 0 &&                    this.body[0].y - this.cellSize !== this.body[1].y                ) {                    this.dY = -1                    this.dX = 0                }                break            }            case 'ArrowDown': {                if (                    this.dY === 0 &&                    this.body[0].y + this.cellSize !== this.body[1].y                ) {                    this.dY = 1                    this.dX = 0                }                break            }            case 'ArrowRight': {                if (                    this.dX === 0 &&                    this.body[0].x + this.cellSize !== this.body[1].x                ) {                    this.dY = 0                    this.dX = 1                }            }                break            case 'ArrowLeft': {                if (                    this.dX === 0 &&                    this.body[0].x - this.cellSize !== this.body[1].x                ) {                    this.dY = 0                    this.dX = -1                }                break            }            case 'x': {                /*cheat*/                this.body.length += 100                break            }        }    }    move() {        if (this.dX || this.dY) {            if (this.body.length > 1) {                for (let i = this.body.length - 1; i > 0; i--) {                    this.body[i] = {...this.body[i - 1]}                }            }            this.body[0].x += this.dX * this.cellSize            this.body[0].y += this.dY * this.cellSize        }    }    isBorder(borderMode) {        let flag =            this.body[0].x === +this.field.width ||            this.body[0].x < 0 ||            this.body[0].y === +this.field.height ||            this.body[0].y < 0        if (borderMode) {            return flag        } else {            // Правая граница            if (this.body[0].x >= this.field.width) {                this.body[0].x = 0            }            // Нижняя граница            if (this.body[0].y >= this.field.height) {                this.body[0].y = 0            }            // Левая граница            if (this.body[0].x < 0) {                this.body[0].x = this.field.width - this.cellSize            }            // Верхняя граница            if (this.body[0].y < 0) {                this.body[0].y = this.field.height - this.cellSize            }        }    }    isSelfAttack() {        let result = false        this.body.forEach((element, i, body) => {            if (body[0].x === element.x && body[0].y === element.y && i !== 0) {                result = true            }        })        return result    }    isFruit(fruitPos) {        return fruitPos.x === this.body[0].x && fruitPos.y === this.body[0].y    }    grow() {        this.body.length++    }}class Fruit {    constructor(color, size, field) {        this.color = color        this.size = size        this.field = field        this.position = {            x: getRandom(this.field.width / this.size) * this.size,            y: getRandom(this.field.height / this.size) * this.size        }    }    setPos(snakeBody) {        const isNumInSnake = ({x, y}) => {            let flag = false            snakeBody.forEach((el) => {                if (el.x === x && el.y === y) {                    flag = true                }            })            return flag        }        do {            this.position.x = getRandom(this.field.width / this.size) * this.size            this.position.y = getRandom(this.field.height / this.size) * this.size        } while (isNumInSnake(this.position))    }}/*=====================================================================*/settingControls.forEach((node) => {    const input = node.querySelector('.range-slider__input')    input.addEventListener('input', inputHandler)    inputHandler(input)})popupOverlay.addEventListener('click', (e) => {    e.target.classList.remove('active')})document.querySelector('.popup__close').addEventListener('click', () => {    popupOverlay.classList.remove('active')})startButton.addEventListener('click', gameInit)settingsButton.addEventListener('click', () => {    popupOverlay.classList.add('active')})function gameInit() {    gameSettings.borderMode = document.getElementById('game-mode').checked    document.querySelectorAll('.input--color').forEach((input) => {        gameSettings.cell[input.id] = input.value    })    const snake = new Snake(gameSettings.cell, gameSettings.field)    const game = new Game(gameSettings, snake.keyHandler)    const fruit = new Fruit(game.cell.fruitColor, game.cell.size, game.field)    mainScreen.classList.add('disabled')    const gameLoop = setInterval(() => {        if (!game.isEnd) {            game.clear()            if (snake.body.length >= (+game.field.width / game.cell.size) * (+game.field.height / game.cell.size) - 1) {                game.end(gameLoop)            }            if (snake.isFruit(fruit.position)) {                game.upScore()                fruit.setPos(snake.body)                snake.grow()            }            snake.move()            if (snake.isBorder(game.borderMode) || snake.isSelfAttack()) {                game.end(gameLoop)            }            game.render(fruit.position, fruit.size, fruit.color)            game.render(snake.body, snake.cellSize, snake.cellColor, snake.headCellColor)        }    }, gameSettings.speed)}